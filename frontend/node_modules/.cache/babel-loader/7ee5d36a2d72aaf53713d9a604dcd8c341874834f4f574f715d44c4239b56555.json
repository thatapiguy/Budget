{"ast":null,"code":"\"use client\";\n\n// packages/react/roving-focus/src/roving-focus-group.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { jsx } from \"react/jsx-runtime\";\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME, [createCollectionScope]);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup,\n    children: /* @__PURE__ */jsx(Collection.Slot, {\n      scope: props.__scopeRovingFocusGroup,\n      children: /* @__PURE__ */jsx(RovingFocusGroupImpl, {\n        ...props,\n        ref: forwardedRef\n      })\n    })\n  });\n});\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */jsx(RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: React.useCallback(tabStopId => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),\n    onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n    onFocusableItemAdd: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount + 1), []),\n    onFocusableItemRemove: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount - 1), []),\n    children: /* @__PURE__ */jsx(Primitive.div, {\n      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n      \"data-orientation\": orientation,\n      ...groupProps,\n      ref: composedRefs,\n      style: {\n        outline: \"none\",\n        ...props.style\n      },\n      onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n        isClickFocusRef.current = true;\n      }),\n      onFocus: composeEventHandlers(props.onFocus, event => {\n        const isKeyboardFocus = !isClickFocusRef.current;\n        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n          event.currentTarget.dispatchEvent(entryFocusEvent);\n          if (!entryFocusEvent.defaultPrevented) {\n            const items = getItems().filter(item => item.focusable);\n            const activeItem = items.find(item => item.active);\n            const currentItem = items.find(item => item.id === currentTabStopId);\n            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);\n            const candidateNodes = candidateItems.map(item => item.ref.current);\n            focusFirst(candidateNodes, preventScrollOnEntryFocus);\n          }\n        }\n        isClickFocusRef.current = false;\n      }),\n      onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))\n    })\n  });\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    focusable = true,\n    active = false,\n    tabStopId,\n    ...itemProps\n  } = props;\n  const autoId = useId();\n  const id = tabStopId || autoId;\n  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const {\n    onFocusableItemAdd,\n    onFocusableItemRemove\n  } = context;\n  React.useEffect(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n  return /* @__PURE__ */jsx(Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active,\n    children: /* @__PURE__ */jsx(Primitive.span, {\n      tabIndex: isCurrentTabStop ? 0 : -1,\n      \"data-orientation\": context.orientation,\n      ...itemProps,\n      ref: forwardedRef,\n      onMouseDown: composeEventHandlers(props.onMouseDown, event => {\n        if (!focusable) event.preventDefault();else context.onItemFocus(id);\n      }),\n      onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        if (event.key === \"Tab\" && event.shiftKey) {\n          context.onItemShiftTab();\n          return;\n        }\n        if (event.target !== event.currentTarget) return;\n        const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n        if (focusIntent !== void 0) {\n          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n          event.preventDefault();\n          const items = getItems().filter(item => item.focusable);\n          let candidateNodes = items.map(item => item.ref.current);\n          if (focusIntent === \"last\") candidateNodes.reverse();else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n            if (focusIntent === \"prev\") candidateNodes.reverse();\n            const currentIndex = candidateNodes.indexOf(event.currentTarget);\n            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n          }\n          setTimeout(() => focusFirst(candidateNodes));\n        }\n      })\n    })\n  });\n});\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates, preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({\n      preventScroll\n    });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;\nexport { Item, Root, RovingFocusGroup, RovingFocusGroupItem, createRovingFocusGroupScope };","map":{"version":3,"names":["React","composeEventHandlers","createCollection","useComposedRefs","createContextScope","useId","Primitive","useCallbackRef","useControllableState","useDirection","jsx","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","cancelable","GROUP_NAME","Collection","useCollection","createCollectionScope","createRovingFocusGroupContext","createRovingFocusGroupScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","forwardRef","props","forwardedRef","Provider","scope","__scopeRovingFocusGroup","children","Slot","RovingFocusGroupImpl","ref","displayName","orientation","loop","dir","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","useRef","composedRefs","direction","setCurrentTabStopId","prop","defaultProp","onChange","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","useEffect","node","current","addEventListener","removeEventListener","onItemFocus","useCallback","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","div","tabIndex","style","outline","onMouseDown","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","items","filter","item","focusable","activeItem","find","active","currentItem","id","candidateItems","Boolean","candidateNodes","map","focusFirst","onBlur","ITEM_NAME","RovingFocusGroupItem","itemProps","autoId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getFocusIntent","metaKey","ctrlKey","altKey","reverse","currentIndex","indexOf","wrapArray","slice","setTimeout","MAP_KEY_TO_FOCUS_INTENT","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","getDirectionAwareKey","includes","candidates","preventScroll","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","array","startIndex","_","index","length","Root","Item"],"sources":["/Users/thatapiguy/Budget/frontend/node_modules/@radix-ui/react-roving-focus/src/roving-focus-group.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}